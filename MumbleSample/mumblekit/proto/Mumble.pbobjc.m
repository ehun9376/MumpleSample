// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// clang-format off
// source: Mumble.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 40311
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 40311 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import <stdatomic.h>

#import "Mumble.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(ACL);
GPBObjCClassDeclaration(ACL_ChanACL);
GPBObjCClassDeclaration(ACL_ChanGroup);
GPBObjCClassDeclaration(Authenticate);
GPBObjCClassDeclaration(BanList);
GPBObjCClassDeclaration(BanList_BanEntry);
GPBObjCClassDeclaration(ChannelRemove);
GPBObjCClassDeclaration(ChannelState);
GPBObjCClassDeclaration(CodecVersion);
GPBObjCClassDeclaration(ContextAction);
GPBObjCClassDeclaration(ContextActionModify);
GPBObjCClassDeclaration(CryptSetup);
GPBObjCClassDeclaration(PermissionDenied);
GPBObjCClassDeclaration(PermissionQuery);
GPBObjCClassDeclaration(Ping);
GPBObjCClassDeclaration(QueryUsers);
GPBObjCClassDeclaration(Reject);
GPBObjCClassDeclaration(RequestBlob);
GPBObjCClassDeclaration(ServerConfig);
GPBObjCClassDeclaration(ServerSync);
GPBObjCClassDeclaration(SuggestConfig);
GPBObjCClassDeclaration(TextMessage);
GPBObjCClassDeclaration(UDPTunnel);
GPBObjCClassDeclaration(UserList);
GPBObjCClassDeclaration(UserList_User);
GPBObjCClassDeclaration(UserRemove);
GPBObjCClassDeclaration(UserState);
GPBObjCClassDeclaration(UserStats);
GPBObjCClassDeclaration(UserStats_Stats);
GPBObjCClassDeclaration(Version);
GPBObjCClassDeclaration(VoiceTarget);
GPBObjCClassDeclaration(VoiceTarget_Target);

#pragma mark - MumbleRoot

@implementation MumbleRoot

// No extensions in the file and no imports or none of the imports (direct or
// indirect) defined extensions, so no need to generate +extensionRegistry.

@end

static GPBFilePackageAndPrefix MumbleRoot_FileDescription = {
  .package = "MumbleProto",
  .prefix = NULL
};

#pragma mark - Enum Reject_RejectType

GPBEnumDescriptor *Reject_RejectType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "None\000WrongVersion\000InvalidUsername\000WrongU"
        "serPw\000WrongServerPw\000UsernameInUse\000Server"
        "Full\000NoCertificate\000";
    static const int32_t values[] = {
        Reject_RejectType_None,
        Reject_RejectType_WrongVersion,
        Reject_RejectType_InvalidUsername,
        Reject_RejectType_WrongUserPw,
        Reject_RejectType_WrongServerPw,
        Reject_RejectType_UsernameInUse,
        Reject_RejectType_ServerFull,
        Reject_RejectType_NoCertificate,
    };
    static const char *extraTextFormatInfo = "\010\000\004\000\001\014\000\002\017\000\003\nA\000\004\014A\000\005\r\000\006\n\000\007\r\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Reject_RejectType)
                                   runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Reject_RejectType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_IsClosed
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Reject_RejectType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Reject_RejectType_None:
    case Reject_RejectType_WrongVersion:
    case Reject_RejectType_InvalidUsername:
    case Reject_RejectType_WrongUserPw:
    case Reject_RejectType_WrongServerPw:
    case Reject_RejectType_UsernameInUse:
    case Reject_RejectType_ServerFull:
    case Reject_RejectType_NoCertificate:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PermissionDenied_DenyType

GPBEnumDescriptor *PermissionDenied_DenyType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Text\000Permission\000SuperUser\000ChannelName\000Te"
        "xtTooLong\000H9K\000TemporaryChannel\000MissingCe"
        "rtificate\000UserName\000ChannelFull\000";
    static const int32_t values[] = {
        PermissionDenied_DenyType_Text,
        PermissionDenied_DenyType_Permission,
        PermissionDenied_DenyType_SuperUser,
        PermissionDenied_DenyType_ChannelName,
        PermissionDenied_DenyType_TextTooLong,
        PermissionDenied_DenyType_H9K,
        PermissionDenied_DenyType_TemporaryChannel,
        PermissionDenied_DenyType_MissingCertificate,
        PermissionDenied_DenyType_UserName,
        PermissionDenied_DenyType_ChannelFull,
    };
    static const char *extraTextFormatInfo = "\n\000\004\000\001\n\000\002\t\000\003\013\000\004\013\000\005\003\000\006\020\000\007\022\000\010\010\000\t\013\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PermissionDenied_DenyType)
                                   runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PermissionDenied_DenyType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_IsClosed
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PermissionDenied_DenyType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PermissionDenied_DenyType_Text:
    case PermissionDenied_DenyType_Permission:
    case PermissionDenied_DenyType_SuperUser:
    case PermissionDenied_DenyType_ChannelName:
    case PermissionDenied_DenyType_TextTooLong:
    case PermissionDenied_DenyType_H9K:
    case PermissionDenied_DenyType_TemporaryChannel:
    case PermissionDenied_DenyType_MissingCertificate:
    case PermissionDenied_DenyType_UserName:
    case PermissionDenied_DenyType_ChannelFull:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ContextActionModify_Context

GPBEnumDescriptor *ContextActionModify_Context_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Server\000Channel\000User\000";
    static const int32_t values[] = {
        ContextActionModify_Context_Server,
        ContextActionModify_Context_Channel,
        ContextActionModify_Context_User,
    };
    static const char *extraTextFormatInfo = "\003\000\006\000\001\007\000\002\004\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ContextActionModify_Context)
                                   runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ContextActionModify_Context_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_IsClosed
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ContextActionModify_Context_IsValidValue(int32_t value__) {
  switch (value__) {
    case ContextActionModify_Context_Server:
    case ContextActionModify_Context_Channel:
    case ContextActionModify_Context_User:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ContextActionModify_Operation

GPBEnumDescriptor *ContextActionModify_Operation_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Add\000Remove\000";
    static const int32_t values[] = {
        ContextActionModify_Operation_Add,
        ContextActionModify_Operation_Remove,
    };
    static const char *extraTextFormatInfo = "\002\000\003\000\001\006\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ContextActionModify_Operation)
                                   runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ContextActionModify_Operation_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_IsClosed
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ContextActionModify_Operation_IsValidValue(int32_t value__) {
  switch (value__) {
    case ContextActionModify_Operation_Add:
    case ContextActionModify_Operation_Remove:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Version

@implementation Version

@dynamic hasVersion, version;
@dynamic hasRelease_p, release_p;
@dynamic hasOs, os;
@dynamic hasOsVersion, osVersion;

typedef struct Version__storage_ {
  uint32_t _has_storage_[1];
  uint32_t version;
  NSString *release_p;
  NSString *os;
  NSString *osVersion;
} Version__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = Version_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Version__storage_, version),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "release_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Version_FieldNumber_Release_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Version__storage_, release_p),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "os",
        .dataTypeSpecific.clazz = Nil,
        .number = Version_FieldNumber_Os,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Version__storage_, os),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "osVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = Version_FieldNumber_OsVersion,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Version__storage_, osVersion),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Version)
                                   messageName:@"Version"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Version__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UDPTunnel

@implementation UDPTunnel

@dynamic hasPacket, packet;

typedef struct UDPTunnel__storage_ {
  uint32_t _has_storage_[1];
  NSData *packet;
} UDPTunnel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "packet",
        .dataTypeSpecific.clazz = Nil,
        .number = UDPTunnel_FieldNumber_Packet,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UDPTunnel__storage_, packet),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UDPTunnel)
                                   messageName:@"UDPTunnel"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UDPTunnel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Authenticate

@implementation Authenticate

@dynamic hasUsername, username;
@dynamic hasPassword, password;
@dynamic tokensArray, tokensArray_Count;
@dynamic celtVersionsArray, celtVersionsArray_Count;
@dynamic hasOpus, opus;

typedef struct Authenticate__storage_ {
  uint32_t _has_storage_[1];
  NSString *username;
  NSString *password;
  NSMutableArray *tokensArray;
  GPBInt32Array *celtVersionsArray;
} Authenticate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "username",
        .dataTypeSpecific.clazz = Nil,
        .number = Authenticate_FieldNumber_Username,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Authenticate__storage_, username),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "password",
        .dataTypeSpecific.clazz = Nil,
        .number = Authenticate_FieldNumber_Password,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Authenticate__storage_, password),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tokensArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Authenticate_FieldNumber_TokensArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Authenticate__storage_, tokensArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "celtVersionsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Authenticate_FieldNumber_CeltVersionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Authenticate__storage_, celtVersionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "opus",
        .dataTypeSpecific.clazz = Nil,
        .number = Authenticate_FieldNumber_Opus,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldHasDefaultValue,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Authenticate)
                                   messageName:@"Authenticate"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Authenticate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Ping

@implementation Ping

@dynamic hasTimestamp, timestamp;
@dynamic hasGood, good;
@dynamic hasLate, late;
@dynamic hasLost, lost;
@dynamic hasResync, resync;
@dynamic hasUdpPackets, udpPackets;
@dynamic hasTcpPackets, tcpPackets;
@dynamic hasUdpPingAvg, udpPingAvg;
@dynamic hasUdpPingVar, udpPingVar;
@dynamic hasTcpPingAvg, tcpPingAvg;
@dynamic hasTcpPingVar, tcpPingVar;

typedef struct Ping__storage_ {
  uint32_t _has_storage_[1];
  uint32_t good;
  uint32_t late;
  uint32_t lost;
  uint32_t resync;
  uint32_t udpPackets;
  uint32_t tcpPackets;
  float udpPingAvg;
  float udpPingVar;
  float tcpPingAvg;
  float tcpPingVar;
  uint64_t timestamp;
} Ping__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = Nil,
        .number = Ping_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Ping__storage_, timestamp),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "good",
        .dataTypeSpecific.clazz = Nil,
        .number = Ping_FieldNumber_Good,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Ping__storage_, good),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "late",
        .dataTypeSpecific.clazz = Nil,
        .number = Ping_FieldNumber_Late,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Ping__storage_, late),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "lost",
        .dataTypeSpecific.clazz = Nil,
        .number = Ping_FieldNumber_Lost,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Ping__storage_, lost),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "resync",
        .dataTypeSpecific.clazz = Nil,
        .number = Ping_FieldNumber_Resync,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Ping__storage_, resync),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "udpPackets",
        .dataTypeSpecific.clazz = Nil,
        .number = Ping_FieldNumber_UdpPackets,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Ping__storage_, udpPackets),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tcpPackets",
        .dataTypeSpecific.clazz = Nil,
        .number = Ping_FieldNumber_TcpPackets,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Ping__storage_, tcpPackets),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "udpPingAvg",
        .dataTypeSpecific.clazz = Nil,
        .number = Ping_FieldNumber_UdpPingAvg,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Ping__storage_, udpPingAvg),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "udpPingVar",
        .dataTypeSpecific.clazz = Nil,
        .number = Ping_FieldNumber_UdpPingVar,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Ping__storage_, udpPingVar),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "tcpPingAvg",
        .dataTypeSpecific.clazz = Nil,
        .number = Ping_FieldNumber_TcpPingAvg,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Ping__storage_, tcpPingAvg),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "tcpPingVar",
        .dataTypeSpecific.clazz = Nil,
        .number = Ping_FieldNumber_TcpPingVar,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Ping__storage_, tcpPingVar),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Ping)
                                   messageName:@"Ping"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Ping__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Reject

@implementation Reject

@dynamic hasType, type;
@dynamic hasReason, reason;

typedef struct Reject__storage_ {
  uint32_t _has_storage_[1];
  Reject_RejectType type;
  NSString *reason;
} Reject__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Reject_RejectType_EnumDescriptor,
        .number = Reject_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Reject__storage_, type),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "reason",
        .dataTypeSpecific.clazz = Nil,
        .number = Reject_FieldNumber_Reason,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Reject__storage_, reason),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Reject)
                                   messageName:@"Reject"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Reject__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServerConfig

@implementation ServerConfig

@dynamic hasMaxBandwidth, maxBandwidth;
@dynamic hasWelcomeText, welcomeText;
@dynamic hasAllowHtml, allowHtml;
@dynamic hasMessageLength, messageLength;
@dynamic hasImageMessageLength, imageMessageLength;

typedef struct ServerConfig__storage_ {
  uint32_t _has_storage_[1];
  uint32_t maxBandwidth;
  uint32_t messageLength;
  uint32_t imageMessageLength;
  NSString *welcomeText;
} ServerConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "maxBandwidth",
        .dataTypeSpecific.clazz = Nil,
        .number = ServerConfig_FieldNumber_MaxBandwidth,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServerConfig__storage_, maxBandwidth),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "welcomeText",
        .dataTypeSpecific.clazz = Nil,
        .number = ServerConfig_FieldNumber_WelcomeText,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ServerConfig__storage_, welcomeText),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "allowHtml",
        .dataTypeSpecific.clazz = Nil,
        .number = ServerConfig_FieldNumber_AllowHtml,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "messageLength",
        .dataTypeSpecific.clazz = Nil,
        .number = ServerConfig_FieldNumber_MessageLength,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ServerConfig__storage_, messageLength),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "imageMessageLength",
        .dataTypeSpecific.clazz = Nil,
        .number = ServerConfig_FieldNumber_ImageMessageLength,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ServerConfig__storage_, imageMessageLength),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ServerConfig)
                                   messageName:@"ServerConfig"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServerConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServerSync

@implementation ServerSync

@dynamic hasSession, session;
@dynamic hasMaxBandwidth, maxBandwidth;
@dynamic hasWelcomeText, welcomeText;
@dynamic hasPermissions, permissions;

typedef struct ServerSync__storage_ {
  uint32_t _has_storage_[1];
  uint32_t session;
  uint32_t maxBandwidth;
  NSString *welcomeText;
  uint64_t permissions;
} ServerSync__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.clazz = Nil,
        .number = ServerSync_FieldNumber_Session,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServerSync__storage_, session),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "maxBandwidth",
        .dataTypeSpecific.clazz = Nil,
        .number = ServerSync_FieldNumber_MaxBandwidth,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ServerSync__storage_, maxBandwidth),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "welcomeText",
        .dataTypeSpecific.clazz = Nil,
        .number = ServerSync_FieldNumber_WelcomeText,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ServerSync__storage_, welcomeText),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "permissions",
        .dataTypeSpecific.clazz = Nil,
        .number = ServerSync_FieldNumber_Permissions,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ServerSync__storage_, permissions),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ServerSync)
                                   messageName:@"ServerSync"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServerSync__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelRemove

@implementation ChannelRemove

@dynamic hasChannelId, channelId;

typedef struct ChannelRemove__storage_ {
  uint32_t _has_storage_[1];
  uint32_t channelId;
} ChannelRemove__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChannelRemove_FieldNumber_ChannelId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelRemove__storage_, channelId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChannelRemove)
                                   messageName:@"ChannelRemove"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelRemove__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelState

@implementation ChannelState

@dynamic hasChannelId, channelId;
@dynamic hasParent, parent;
@dynamic hasName, name;
@dynamic linksArray, linksArray_Count;
@dynamic hasDescription_p, description_p;
@dynamic linksAddArray, linksAddArray_Count;
@dynamic linksRemoveArray, linksRemoveArray_Count;
@dynamic hasTemporary, temporary;
@dynamic hasPosition, position;
@dynamic hasDescriptionHash, descriptionHash;

typedef struct ChannelState__storage_ {
  uint32_t _has_storage_[1];
  uint32_t channelId;
  uint32_t parent;
  int32_t position;
  NSString *name;
  GPBUInt32Array *linksArray;
  NSString *description_p;
  GPBUInt32Array *linksAddArray;
  GPBUInt32Array *linksRemoveArray;
  NSData *descriptionHash;
} ChannelState__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChannelState_FieldNumber_ChannelId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelState__storage_, channelId),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "parent",
        .dataTypeSpecific.clazz = Nil,
        .number = ChannelState_FieldNumber_Parent,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChannelState__storage_, parent),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = ChannelState_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChannelState__storage_, name),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "linksArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ChannelState_FieldNumber_LinksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChannelState__storage_, linksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.clazz = Nil,
        .number = ChannelState_FieldNumber_Description_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChannelState__storage_, description_p),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "linksAddArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ChannelState_FieldNumber_LinksAddArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChannelState__storage_, linksAddArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "linksRemoveArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ChannelState_FieldNumber_LinksRemoveArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChannelState__storage_, linksRemoveArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "temporary",
        .dataTypeSpecific.clazz = Nil,
        .number = ChannelState_FieldNumber_Temporary,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldHasDefaultValue,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "position",
        .dataTypeSpecific.clazz = Nil,
        .number = ChannelState_FieldNumber_Position,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ChannelState__storage_, position),
        .flags = GPBFieldHasDefaultValue,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "descriptionHash",
        .dataTypeSpecific.clazz = Nil,
        .number = ChannelState_FieldNumber_DescriptionHash,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ChannelState__storage_, descriptionHash),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChannelState)
                                   messageName:@"ChannelState"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelState__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserRemove

@implementation UserRemove

@dynamic hasSession, session;
@dynamic hasActor, actor;
@dynamic hasReason, reason;
@dynamic hasBan, ban;

typedef struct UserRemove__storage_ {
  uint32_t _has_storage_[1];
  uint32_t session;
  uint32_t actor;
  NSString *reason;
} UserRemove__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.clazz = Nil,
        .number = UserRemove_FieldNumber_Session,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserRemove__storage_, session),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "actor",
        .dataTypeSpecific.clazz = Nil,
        .number = UserRemove_FieldNumber_Actor,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserRemove__storage_, actor),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "reason",
        .dataTypeSpecific.clazz = Nil,
        .number = UserRemove_FieldNumber_Reason,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserRemove__storage_, reason),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ban",
        .dataTypeSpecific.clazz = Nil,
        .number = UserRemove_FieldNumber_Ban,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UserRemove)
                                   messageName:@"UserRemove"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserRemove__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserState

@implementation UserState

@dynamic hasSession, session;
@dynamic hasActor, actor;
@dynamic hasName, name;
@dynamic hasUserId, userId;
@dynamic hasChannelId, channelId;
@dynamic hasMute, mute;
@dynamic hasDeaf, deaf;
@dynamic hasSuppress, suppress;
@dynamic hasSelfMute, selfMute;
@dynamic hasSelfDeaf, selfDeaf;
@dynamic hasTexture, texture;
@dynamic hasPluginContext, pluginContext;
@dynamic hasPluginIdentity, pluginIdentity;
@dynamic hasComment, comment;
@dynamic hasCertHash, certHash;
@dynamic hasCommentHash, commentHash;
@dynamic hasTextureHash, textureHash;
@dynamic hasPrioritySpeaker, prioritySpeaker;
@dynamic hasRecording, recording;

typedef struct UserState__storage_ {
  uint32_t _has_storage_[1];
  uint32_t session;
  uint32_t actor;
  uint32_t userId;
  uint32_t channelId;
  NSString *name;
  NSData *texture;
  NSData *pluginContext;
  NSString *pluginIdentity;
  NSString *comment;
  NSString *certHash;
  NSData *commentHash;
  NSData *textureHash;
} UserState__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.clazz = Nil,
        .number = UserState_FieldNumber_Session,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserState__storage_, session),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "actor",
        .dataTypeSpecific.clazz = Nil,
        .number = UserState_FieldNumber_Actor,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserState__storage_, actor),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = UserState_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserState__storage_, name),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = UserState_FieldNumber_UserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserState__storage_, userId),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "channelId",
        .dataTypeSpecific.clazz = Nil,
        .number = UserState_FieldNumber_ChannelId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UserState__storage_, channelId),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "mute",
        .dataTypeSpecific.clazz = Nil,
        .number = UserState_FieldNumber_Mute,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "deaf",
        .dataTypeSpecific.clazz = Nil,
        .number = UserState_FieldNumber_Deaf,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "suppress",
        .dataTypeSpecific.clazz = Nil,
        .number = UserState_FieldNumber_Suppress,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "selfMute",
        .dataTypeSpecific.clazz = Nil,
        .number = UserState_FieldNumber_SelfMute,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "selfDeaf",
        .dataTypeSpecific.clazz = Nil,
        .number = UserState_FieldNumber_SelfDeaf,
        .hasIndex = 13,
        .offset = 14,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "texture",
        .dataTypeSpecific.clazz = Nil,
        .number = UserState_FieldNumber_Texture,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(UserState__storage_, texture),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "pluginContext",
        .dataTypeSpecific.clazz = Nil,
        .number = UserState_FieldNumber_PluginContext,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(UserState__storage_, pluginContext),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "pluginIdentity",
        .dataTypeSpecific.clazz = Nil,
        .number = UserState_FieldNumber_PluginIdentity,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(UserState__storage_, pluginIdentity),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "comment",
        .dataTypeSpecific.clazz = Nil,
        .number = UserState_FieldNumber_Comment,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(UserState__storage_, comment),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "certHash",
        .dataTypeSpecific.clazz = Nil,
        .number = UserState_FieldNumber_CertHash,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(UserState__storage_, certHash),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "commentHash",
        .dataTypeSpecific.clazz = Nil,
        .number = UserState_FieldNumber_CommentHash,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(UserState__storage_, commentHash),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "textureHash",
        .dataTypeSpecific.clazz = Nil,
        .number = UserState_FieldNumber_TextureHash,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(UserState__storage_, textureHash),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "prioritySpeaker",
        .dataTypeSpecific.clazz = Nil,
        .number = UserState_FieldNumber_PrioritySpeaker,
        .hasIndex = 22,
        .offset = 23,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "recording",
        .dataTypeSpecific.clazz = Nil,
        .number = UserState_FieldNumber_Recording,
        .hasIndex = 24,
        .offset = 25,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UserState)
                                   messageName:@"UserState"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserState__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BanList

@implementation BanList

@dynamic bansArray, bansArray_Count;
@dynamic hasQuery, query;

typedef struct BanList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *bansArray;
} BanList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bansArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BanList_BanEntry),
        .number = BanList_FieldNumber_BansArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BanList__storage_, bansArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "query",
        .dataTypeSpecific.clazz = Nil,
        .number = BanList_FieldNumber_Query,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldHasDefaultValue,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BanList)
                                   messageName:@"BanList"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BanList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BanList_BanEntry

@implementation BanList_BanEntry

@dynamic hasAddress, address;
@dynamic hasMask, mask;
@dynamic hasName, name;
@dynamic hasCertHash, certHash;
@dynamic hasReason, reason;
@dynamic hasStart, start;
@dynamic hasDuration, duration;

typedef struct BanList_BanEntry__storage_ {
  uint32_t _has_storage_[1];
  uint32_t mask;
  uint32_t duration;
  NSData *address;
  NSString *name;
  NSString *certHash;
  NSString *reason;
  NSString *start;
} BanList_BanEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = BanList_BanEntry_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BanList_BanEntry__storage_, address),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "mask",
        .dataTypeSpecific.clazz = Nil,
        .number = BanList_BanEntry_FieldNumber_Mask,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BanList_BanEntry__storage_, mask),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = BanList_BanEntry_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BanList_BanEntry__storage_, name),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "certHash",
        .dataTypeSpecific.clazz = Nil,
        .number = BanList_BanEntry_FieldNumber_CertHash,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BanList_BanEntry__storage_, certHash),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "reason",
        .dataTypeSpecific.clazz = Nil,
        .number = BanList_BanEntry_FieldNumber_Reason,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BanList_BanEntry__storage_, reason),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "start",
        .dataTypeSpecific.clazz = Nil,
        .number = BanList_BanEntry_FieldNumber_Start,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BanList_BanEntry__storage_, start),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "duration",
        .dataTypeSpecific.clazz = Nil,
        .number = BanList_BanEntry_FieldNumber_Duration,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BanList_BanEntry__storage_, duration),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BanList_BanEntry)
                                   messageName:@"BanEntry"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BanList_BanEntry__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(BanList)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TextMessage

@implementation TextMessage

@dynamic hasActor, actor;
@dynamic sessionArray, sessionArray_Count;
@dynamic channelIdArray, channelIdArray_Count;
@dynamic treeIdArray, treeIdArray_Count;
@dynamic hasMessage, message;

typedef struct TextMessage__storage_ {
  uint32_t _has_storage_[1];
  uint32_t actor;
  GPBUInt32Array *sessionArray;
  GPBUInt32Array *channelIdArray;
  GPBUInt32Array *treeIdArray;
  NSString *message;
} TextMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "actor",
        .dataTypeSpecific.clazz = Nil,
        .number = TextMessage_FieldNumber_Actor,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TextMessage__storage_, actor),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sessionArray",
        .dataTypeSpecific.clazz = Nil,
        .number = TextMessage_FieldNumber_SessionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TextMessage__storage_, sessionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "channelIdArray",
        .dataTypeSpecific.clazz = Nil,
        .number = TextMessage_FieldNumber_ChannelIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TextMessage__storage_, channelIdArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "treeIdArray",
        .dataTypeSpecific.clazz = Nil,
        .number = TextMessage_FieldNumber_TreeIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TextMessage__storage_, treeIdArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = TextMessage_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TextMessage__storage_, message),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TextMessage)
                                   messageName:@"TextMessage"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TextMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PermissionDenied

@implementation PermissionDenied

@dynamic hasPermission, permission;
@dynamic hasChannelId, channelId;
@dynamic hasSession, session;
@dynamic hasReason, reason;
@dynamic hasType, type;
@dynamic hasName, name;

typedef struct PermissionDenied__storage_ {
  uint32_t _has_storage_[1];
  uint32_t permission;
  uint32_t channelId;
  uint32_t session;
  PermissionDenied_DenyType type;
  NSString *reason;
  NSString *name;
} PermissionDenied__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "permission",
        .dataTypeSpecific.clazz = Nil,
        .number = PermissionDenied_FieldNumber_Permission,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PermissionDenied__storage_, permission),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "channelId",
        .dataTypeSpecific.clazz = Nil,
        .number = PermissionDenied_FieldNumber_ChannelId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PermissionDenied__storage_, channelId),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "session",
        .dataTypeSpecific.clazz = Nil,
        .number = PermissionDenied_FieldNumber_Session,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PermissionDenied__storage_, session),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "reason",
        .dataTypeSpecific.clazz = Nil,
        .number = PermissionDenied_FieldNumber_Reason,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PermissionDenied__storage_, reason),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PermissionDenied_DenyType_EnumDescriptor,
        .number = PermissionDenied_FieldNumber_Type,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PermissionDenied__storage_, type),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = PermissionDenied_FieldNumber_Name,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PermissionDenied__storage_, name),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(PermissionDenied)
                                   messageName:@"PermissionDenied"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PermissionDenied__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACL

@implementation ACL

@dynamic hasChannelId, channelId;
@dynamic hasInheritAcls, inheritAcls;
@dynamic groupsArray, groupsArray_Count;
@dynamic aclsArray, aclsArray_Count;
@dynamic hasQuery, query;

typedef struct ACL__storage_ {
  uint32_t _has_storage_[1];
  uint32_t channelId;
  NSMutableArray *groupsArray;
  NSMutableArray *aclsArray;
} ACL__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "channelId",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ACL_FieldNumber_ChannelId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ACL__storage_, channelId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueBool = YES,
        .core.name = "inheritAcls",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ACL_FieldNumber_InheritAcls,
        .core.hasIndex = 1,
        .core.offset = 2,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldHasDefaultValue,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "groupsArray",
        .core.dataTypeSpecific.clazz = GPBObjCClass(ACL_ChanGroup),
        .core.number = ACL_FieldNumber_GroupsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(ACL__storage_, groupsArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "aclsArray",
        .core.dataTypeSpecific.clazz = GPBObjCClass(ACL_ChanACL),
        .core.number = ACL_FieldNumber_AclsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(ACL__storage_, aclsArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "query",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ACL_FieldNumber_Query,
        .core.hasIndex = 3,
        .core.offset = 4,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldHasDefaultValue,
        .core.dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ACL)
                                   messageName:@"ACL"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ACL__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACL_ChanGroup

@implementation ACL_ChanGroup

@dynamic hasName, name;
@dynamic hasInherited, inherited;
@dynamic hasInherit, inherit;
@dynamic hasInheritable, inheritable;
@dynamic addArray, addArray_Count;
@dynamic removeArray, removeArray_Count;
@dynamic inheritedMembersArray, inheritedMembersArray_Count;

typedef struct ACL_ChanGroup__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  GPBUInt32Array *addArray;
  GPBUInt32Array *removeArray;
  GPBUInt32Array *inheritedMembersArray;
} ACL_ChanGroup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "name",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ACL_ChanGroup_FieldNumber_Name,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ACL_ChanGroup__storage_, name),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueBool = YES,
        .core.name = "inherited",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ACL_ChanGroup_FieldNumber_Inherited,
        .core.hasIndex = 1,
        .core.offset = 2,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldHasDefaultValue,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = YES,
        .core.name = "inherit",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ACL_ChanGroup_FieldNumber_Inherit,
        .core.hasIndex = 3,
        .core.offset = 4,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldHasDefaultValue,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = YES,
        .core.name = "inheritable",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ACL_ChanGroup_FieldNumber_Inheritable,
        .core.hasIndex = 5,
        .core.offset = 6,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldHasDefaultValue,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "addArray",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ACL_ChanGroup_FieldNumber_AddArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(ACL_ChanGroup__storage_, addArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "removeArray",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ACL_ChanGroup_FieldNumber_RemoveArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(ACL_ChanGroup__storage_, removeArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "inheritedMembersArray",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ACL_ChanGroup_FieldNumber_InheritedMembersArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(ACL_ChanGroup__storage_, inheritedMembersArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ACL_ChanGroup)
                                   messageName:@"ChanGroup"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ACL_ChanGroup__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ACL)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACL_ChanACL

@implementation ACL_ChanACL

@dynamic hasApplyHere, applyHere;
@dynamic hasApplySubs, applySubs;
@dynamic hasInherited, inherited;
@dynamic hasUserId, userId;
@dynamic hasGroup, group;
@dynamic hasGrant, grant;
@dynamic hasDeny, deny;

typedef struct ACL_ChanACL__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  uint32_t grant;
  uint32_t deny;
  NSString *group;
} ACL_ChanACL__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueBool = YES,
        .core.name = "applyHere",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ACL_ChanACL_FieldNumber_ApplyHere,
        .core.hasIndex = 0,
        .core.offset = 1,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldHasDefaultValue,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = YES,
        .core.name = "applySubs",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ACL_ChanACL_FieldNumber_ApplySubs,
        .core.hasIndex = 2,
        .core.offset = 3,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldHasDefaultValue,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = YES,
        .core.name = "inherited",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ACL_ChanACL_FieldNumber_Inherited,
        .core.hasIndex = 4,
        .core.offset = 5,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldHasDefaultValue,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "userId",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ACL_ChanACL_FieldNumber_UserId,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(ACL_ChanACL__storage_, userId),
        .core.flags = GPBFieldNone,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "group",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ACL_ChanACL_FieldNumber_Group,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(ACL_ChanACL__storage_, group),
        .core.flags = GPBFieldNone,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "grant",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ACL_ChanACL_FieldNumber_Grant,
        .core.hasIndex = 8,
        .core.offset = (uint32_t)offsetof(ACL_ChanACL__storage_, grant),
        .core.flags = GPBFieldNone,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "deny",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ACL_ChanACL_FieldNumber_Deny,
        .core.hasIndex = 9,
        .core.offset = (uint32_t)offsetof(ACL_ChanACL__storage_, deny),
        .core.flags = GPBFieldNone,
        .core.dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ACL_ChanACL)
                                   messageName:@"ChanACL"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ACL_ChanACL__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ACL)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QueryUsers

@implementation QueryUsers

@dynamic idsArray, idsArray_Count;
@dynamic namesArray, namesArray_Count;

typedef struct QueryUsers__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt32Array *idsArray;
  NSMutableArray *namesArray;
} QueryUsers__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "idsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = QueryUsers_FieldNumber_IdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QueryUsers__storage_, idsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "namesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = QueryUsers_FieldNumber_NamesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QueryUsers__storage_, namesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QueryUsers)
                                   messageName:@"QueryUsers"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QueryUsers__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CryptSetup

@implementation CryptSetup

@dynamic hasKey, key;
@dynamic hasClientNonce, clientNonce;
@dynamic hasServerNonce, serverNonce;

typedef struct CryptSetup__storage_ {
  uint32_t _has_storage_[1];
  NSData *key;
  NSData *clientNonce;
  NSData *serverNonce;
} CryptSetup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = CryptSetup_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CryptSetup__storage_, key),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "clientNonce",
        .dataTypeSpecific.clazz = Nil,
        .number = CryptSetup_FieldNumber_ClientNonce,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CryptSetup__storage_, clientNonce),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "serverNonce",
        .dataTypeSpecific.clazz = Nil,
        .number = CryptSetup_FieldNumber_ServerNonce,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CryptSetup__storage_, serverNonce),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CryptSetup)
                                   messageName:@"CryptSetup"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CryptSetup__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ContextActionModify

@implementation ContextActionModify

@dynamic hasAction, action;
@dynamic hasText, text;
@dynamic hasContext, context;
@dynamic hasOperation, operation;

typedef struct ContextActionModify__storage_ {
  uint32_t _has_storage_[1];
  uint32_t context;
  ContextActionModify_Operation operation;
  NSString *action;
  NSString *text;
} ContextActionModify__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = ContextActionModify_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ContextActionModify__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = ContextActionModify_FieldNumber_Text,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ContextActionModify__storage_, text),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "context",
        .dataTypeSpecific.clazz = Nil,
        .number = ContextActionModify_FieldNumber_Context,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ContextActionModify__storage_, context),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "operation",
        .dataTypeSpecific.enumDescFunc = ContextActionModify_Operation_EnumDescriptor,
        .number = ContextActionModify_FieldNumber_Operation,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ContextActionModify__storage_, operation),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ContextActionModify)
                                   messageName:@"ContextActionModify"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ContextActionModify__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ContextAction

@implementation ContextAction

@dynamic hasSession, session;
@dynamic hasChannelId, channelId;
@dynamic hasAction, action;

typedef struct ContextAction__storage_ {
  uint32_t _has_storage_[1];
  uint32_t session;
  uint32_t channelId;
  NSString *action;
} ContextAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.clazz = Nil,
        .number = ContextAction_FieldNumber_Session,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ContextAction__storage_, session),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "channelId",
        .dataTypeSpecific.clazz = Nil,
        .number = ContextAction_FieldNumber_ChannelId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ContextAction__storage_, channelId),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = ContextAction_FieldNumber_Action,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ContextAction__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ContextAction)
                                   messageName:@"ContextAction"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ContextAction__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserList

@implementation UserList

@dynamic usersArray, usersArray_Count;

typedef struct UserList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *usersArray;
} UserList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "usersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UserList_User),
        .number = UserList_FieldNumber_UsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserList__storage_, usersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UserList)
                                   messageName:@"UserList"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserList_User

@implementation UserList_User

@dynamic hasUserId, userId;
@dynamic hasName, name;

typedef struct UserList_User__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  NSString *name;
} UserList_User__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = UserList_User_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserList_User__storage_, userId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = UserList_User_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserList_User__storage_, name),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UserList_User)
                                   messageName:@"User"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserList_User__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(UserList)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VoiceTarget

@implementation VoiceTarget

@dynamic hasId_p, id_p;
@dynamic targetsArray, targetsArray_Count;

typedef struct VoiceTarget__storage_ {
  uint32_t _has_storage_[1];
  uint32_t id_p;
  NSMutableArray *targetsArray;
} VoiceTarget__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = VoiceTarget_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VoiceTarget__storage_, id_p),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "targetsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(VoiceTarget_Target),
        .number = VoiceTarget_FieldNumber_TargetsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VoiceTarget__storage_, targetsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VoiceTarget)
                                   messageName:@"VoiceTarget"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VoiceTarget__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VoiceTarget_Target

@implementation VoiceTarget_Target

@dynamic sessionArray, sessionArray_Count;
@dynamic hasChannelId, channelId;
@dynamic hasGroup, group;
@dynamic hasLinks, links;
@dynamic hasChildren, children;

typedef struct VoiceTarget_Target__storage_ {
  uint32_t _has_storage_[1];
  uint32_t channelId;
  GPBUInt32Array *sessionArray;
  NSString *group;
} VoiceTarget_Target__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VoiceTarget_Target_FieldNumber_SessionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VoiceTarget_Target__storage_, sessionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "channelId",
        .dataTypeSpecific.clazz = Nil,
        .number = VoiceTarget_Target_FieldNumber_ChannelId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VoiceTarget_Target__storage_, channelId),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "group",
        .dataTypeSpecific.clazz = Nil,
        .number = VoiceTarget_Target_FieldNumber_Group,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VoiceTarget_Target__storage_, group),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "links",
        .dataTypeSpecific.clazz = Nil,
        .number = VoiceTarget_Target_FieldNumber_Links,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldHasDefaultValue,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "children",
        .dataTypeSpecific.clazz = Nil,
        .number = VoiceTarget_Target_FieldNumber_Children,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldHasDefaultValue,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VoiceTarget_Target)
                                   messageName:@"Target"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VoiceTarget_Target__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(VoiceTarget)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PermissionQuery

@implementation PermissionQuery

@dynamic hasChannelId, channelId;
@dynamic hasPermissions, permissions;
@dynamic hasFlush, flush;

typedef struct PermissionQuery__storage_ {
  uint32_t _has_storage_[1];
  uint32_t channelId;
  uint32_t permissions;
} PermissionQuery__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelId",
        .dataTypeSpecific.clazz = Nil,
        .number = PermissionQuery_FieldNumber_ChannelId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PermissionQuery__storage_, channelId),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "permissions",
        .dataTypeSpecific.clazz = Nil,
        .number = PermissionQuery_FieldNumber_Permissions,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PermissionQuery__storage_, permissions),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "flush",
        .dataTypeSpecific.clazz = Nil,
        .number = PermissionQuery_FieldNumber_Flush,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldHasDefaultValue,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(PermissionQuery)
                                   messageName:@"PermissionQuery"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PermissionQuery__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CodecVersion

@implementation CodecVersion

@dynamic hasAlpha, alpha;
@dynamic hasBeta, beta;
@dynamic hasPreferAlpha, preferAlpha;
@dynamic hasOpus, opus;

typedef struct CodecVersion__storage_ {
  uint32_t _has_storage_[1];
  int32_t alpha;
  int32_t beta;
} CodecVersion__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "alpha",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = CodecVersion_FieldNumber_Alpha,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(CodecVersion__storage_, alpha),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "beta",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = CodecVersion_FieldNumber_Beta,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(CodecVersion__storage_, beta),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueBool = YES,
        .core.name = "preferAlpha",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = CodecVersion_FieldNumber_PreferAlpha,
        .core.hasIndex = 2,
        .core.offset = 3,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "opus",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = CodecVersion_FieldNumber_Opus,
        .core.hasIndex = 4,
        .core.offset = 5,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldHasDefaultValue,
        .core.dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CodecVersion)
                                   messageName:@"CodecVersion"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(CodecVersion__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserStats

@implementation UserStats

@dynamic hasSession, session;
@dynamic hasStatsOnly, statsOnly;
@dynamic certificatesArray, certificatesArray_Count;
@dynamic hasFromClient, fromClient;
@dynamic hasFromServer, fromServer;
@dynamic hasUdpPackets, udpPackets;
@dynamic hasTcpPackets, tcpPackets;
@dynamic hasUdpPingAvg, udpPingAvg;
@dynamic hasUdpPingVar, udpPingVar;
@dynamic hasTcpPingAvg, tcpPingAvg;
@dynamic hasTcpPingVar, tcpPingVar;
@dynamic hasVersion, version;
@dynamic celtVersionsArray, celtVersionsArray_Count;
@dynamic hasAddress, address;
@dynamic hasBandwidth, bandwidth;
@dynamic hasOnlinesecs, onlinesecs;
@dynamic hasIdlesecs, idlesecs;
@dynamic hasStrongCertificate, strongCertificate;
@dynamic hasOpus, opus;

typedef struct UserStats__storage_ {
  uint32_t _has_storage_[1];
  uint32_t session;
  uint32_t udpPackets;
  uint32_t tcpPackets;
  float udpPingAvg;
  float udpPingVar;
  float tcpPingAvg;
  float tcpPingVar;
  uint32_t bandwidth;
  uint32_t onlinesecs;
  uint32_t idlesecs;
  NSMutableArray *certificatesArray;
  UserStats_Stats *fromClient;
  UserStats_Stats *fromServer;
  Version *version;
  GPBInt32Array *celtVersionsArray;
  NSData *address;
} UserStats__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.clazz = Nil,
        .number = UserStats_FieldNumber_Session,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserStats__storage_, session),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "statsOnly",
        .dataTypeSpecific.clazz = Nil,
        .number = UserStats_FieldNumber_StatsOnly,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldHasDefaultValue,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "certificatesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = UserStats_FieldNumber_CertificatesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserStats__storage_, certificatesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "fromClient",
        .dataTypeSpecific.clazz = GPBObjCClass(UserStats_Stats),
        .number = UserStats_FieldNumber_FromClient,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserStats__storage_, fromClient),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fromServer",
        .dataTypeSpecific.clazz = GPBObjCClass(UserStats_Stats),
        .number = UserStats_FieldNumber_FromServer,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UserStats__storage_, fromServer),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "udpPackets",
        .dataTypeSpecific.clazz = Nil,
        .number = UserStats_FieldNumber_UdpPackets,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UserStats__storage_, udpPackets),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tcpPackets",
        .dataTypeSpecific.clazz = Nil,
        .number = UserStats_FieldNumber_TcpPackets,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UserStats__storage_, tcpPackets),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "udpPingAvg",
        .dataTypeSpecific.clazz = Nil,
        .number = UserStats_FieldNumber_UdpPingAvg,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(UserStats__storage_, udpPingAvg),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "udpPingVar",
        .dataTypeSpecific.clazz = Nil,
        .number = UserStats_FieldNumber_UdpPingVar,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(UserStats__storage_, udpPingVar),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "tcpPingAvg",
        .dataTypeSpecific.clazz = Nil,
        .number = UserStats_FieldNumber_TcpPingAvg,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(UserStats__storage_, tcpPingAvg),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "tcpPingVar",
        .dataTypeSpecific.clazz = Nil,
        .number = UserStats_FieldNumber_TcpPingVar,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(UserStats__storage_, tcpPingVar),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "version",
        .dataTypeSpecific.clazz = GPBObjCClass(Version),
        .number = UserStats_FieldNumber_Version,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(UserStats__storage_, version),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "celtVersionsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = UserStats_FieldNumber_CeltVersionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserStats__storage_, celtVersionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = UserStats_FieldNumber_Address,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(UserStats__storage_, address),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "bandwidth",
        .dataTypeSpecific.clazz = Nil,
        .number = UserStats_FieldNumber_Bandwidth,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(UserStats__storage_, bandwidth),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "onlinesecs",
        .dataTypeSpecific.clazz = Nil,
        .number = UserStats_FieldNumber_Onlinesecs,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(UserStats__storage_, onlinesecs),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "idlesecs",
        .dataTypeSpecific.clazz = Nil,
        .number = UserStats_FieldNumber_Idlesecs,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(UserStats__storage_, idlesecs),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "strongCertificate",
        .dataTypeSpecific.clazz = Nil,
        .number = UserStats_FieldNumber_StrongCertificate,
        .hasIndex = 16,
        .offset = 17,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldHasDefaultValue,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "opus",
        .dataTypeSpecific.clazz = Nil,
        .number = UserStats_FieldNumber_Opus,
        .hasIndex = 18,
        .offset = 19,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldHasDefaultValue,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UserStats)
                                   messageName:@"UserStats"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserStats__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserStats_Stats

@implementation UserStats_Stats

@dynamic hasGood, good;
@dynamic hasLate, late;
@dynamic hasLost, lost;
@dynamic hasResync, resync;

typedef struct UserStats_Stats__storage_ {
  uint32_t _has_storage_[1];
  uint32_t good;
  uint32_t late;
  uint32_t lost;
  uint32_t resync;
} UserStats_Stats__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "good",
        .dataTypeSpecific.clazz = Nil,
        .number = UserStats_Stats_FieldNumber_Good,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserStats_Stats__storage_, good),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "late",
        .dataTypeSpecific.clazz = Nil,
        .number = UserStats_Stats_FieldNumber_Late,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserStats_Stats__storage_, late),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "lost",
        .dataTypeSpecific.clazz = Nil,
        .number = UserStats_Stats_FieldNumber_Lost,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserStats_Stats__storage_, lost),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "resync",
        .dataTypeSpecific.clazz = Nil,
        .number = UserStats_Stats_FieldNumber_Resync,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserStats_Stats__storage_, resync),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UserStats_Stats)
                                   messageName:@"Stats"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserStats_Stats__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(UserStats)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SuggestConfig

@implementation SuggestConfig

@dynamic hasVersion, version;
@dynamic hasPositional, positional;
@dynamic hasPushToTalk, pushToTalk;

typedef struct SuggestConfig__storage_ {
  uint32_t _has_storage_[1];
  uint32_t version;
} SuggestConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = SuggestConfig_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SuggestConfig__storage_, version),
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "positional",
        .dataTypeSpecific.clazz = Nil,
        .number = SuggestConfig_FieldNumber_Positional,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "pushToTalk",
        .dataTypeSpecific.clazz = Nil,
        .number = SuggestConfig_FieldNumber_PushToTalk,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldNone,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SuggestConfig)
                                   messageName:@"SuggestConfig"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SuggestConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestBlob

@implementation RequestBlob

@dynamic sessionTextureArray, sessionTextureArray_Count;
@dynamic sessionCommentArray, sessionCommentArray_Count;
@dynamic channelDescriptionArray, channelDescriptionArray_Count;

typedef struct RequestBlob__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt32Array *sessionTextureArray;
  GPBUInt32Array *sessionCommentArray;
  GPBUInt32Array *channelDescriptionArray;
} RequestBlob__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionTextureArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestBlob_FieldNumber_SessionTextureArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestBlob__storage_, sessionTextureArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sessionCommentArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestBlob_FieldNumber_SessionCommentArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestBlob__storage_, sessionCommentArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "channelDescriptionArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestBlob_FieldNumber_ChannelDescriptionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestBlob__storage_, channelDescriptionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RequestBlob)
                                   messageName:@"RequestBlob"
                                runtimeSupport:&GOOGLE_PROTOBUF_OBJC_EXPECTED_GENCODE_VERSION_40311
                               fileDescription:&MumbleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestBlob__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
